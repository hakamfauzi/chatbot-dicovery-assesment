<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chatbot</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <main>
        <div class="header">
            <h1>Discovery Assesment</h1>
            <p>Obrolan interaktif untuk mapping prioritas usecase</p>
        </div>

        <div class="chat-container">
            <div id="chatMessages" class="chat-messages"></div>
            <div id="loading" style="display: none;" class="loading-row">
                <div class="spinner"></div>
                <span>Meminta jawaban dari Gemini...</span>
            </div>
            <div class="chat-input-row">
                <input id="chatInput" type="text" placeholder="Tulis pesan dan tekan Enter..." />
                <button id="sendButton">Kirim</button>
            </div>
        </div>

        <section class="mapping-section">
            <h2>Mapping Position (Business Impact vs Technical Feasibility)</h2>
            <div class="chart-container">
                <canvas id="mappingChart"></canvas>
            </div>
            <div class="control-row">
                <button id="saveButton" disabled>Simpan ke Spreadsheet</button>
                <button id="loadSheetButton" class="secondary">Muat dari Spreadsheet</button>
                <span id="saveStatus" class="status"></span>
            </div>
            <div class="sheet-list">
                <h3>Daftar dari Spreadsheet</h3>
                <div id="sheetCount" class="status"></div>
                <table id="sheetTable" class="data-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Use case</th>
                            <th>Domain</th>
                            <th>Impact</th>
                            <th>Feasibility</th>
                            <th>Total</th>
                            <th>Priority</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </section>
    </main>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const loading = document.getElementById('loading');
        const saveButton = document.getElementById('saveButton');
        const loadSheetButton = document.getElementById('loadSheetButton');
        const saveStatus = document.getElementById('saveStatus');
        const sheetCount = document.getElementById('sheetCount');
        const sheetTable = document.getElementById('sheetTable');
        const mappingCanvas = document.getElementById('mappingChart');

        const conversation = [];
        const sheetItems = [];
        const questionsList = [];
        let questionsLoaded = false;
        let lastAssessment = null;
        let mappingChart = null;
        let qnaActive = false;
        let qnaStep = 1;
        let qnaCategory = '';

        
        // Helper: fetch dengan timeout menggunakan AbortController
        const fetchWithTimeout = async (url, options = {}, ms = 60000) => {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), ms);
            try {
                return await fetch(url, { ...options, signal: controller.signal });
            } catch (err) {
                if (err?.name === 'AbortError' || String(err?.message || '').toLowerCase().includes('abort')) {
                    throw new Error(`Timeout: permintaan melebihi batas waktu (${ms / 1000}s).`);
                }
                throw err;
            } finally {
                clearTimeout(id);
            }
        };

        const initChart = () => {
            if (!mappingCanvas) return;
            const ctx = mappingCanvas.getContext('2d');
            mappingChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Use Cases',
                        data: [],
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        parsing: false,
                        pointBackgroundColor: (context) => {
                            const raw = context.raw || {};
                            if (raw.invalid) return '#9e9e9e';
                            return getColorByPriority(raw.priority);
                        },
                        pointBorderColor: (context) => {
                            const raw = context.raw || {};
                            if (raw.invalid) return '#9e9e9e';
                            return getColorByPriority(raw.priority);
                        }
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    scales: {
                        x: { min: 0, max: 100, title: { display: true, text: 'Technical Feasibility (X)' } },
                        y: { min: 0, max: 100, title: { display: true, text: 'Business Impact (Y)' } }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const d = ctx.raw || {};
                                    const name = d.label || 'Use case';
                                    return `${name}: Impact ${d.y}, Feasibility ${d.x}`;
                                }
                            }
                        },
                        legend: { display: true }
                    },
                    elements: { point: { borderWidth: 1 } }
                }
            });
        };

        const getColorByPriority = (priority) => {
            const p = String(priority || '').toLowerCase();
            if (p.includes('quick')) return '#2e7d32'; // hijau
            if (p.includes('second')) return '#f9a825'; // kuning
            if (p.includes('watch') || p.includes('experiment')) return '#1565c0'; // biru
            if (p.includes('defer')) return '#9e9e9e'; // abu
            return '#673ab7'; // fallback ungu
        };

        const getPriorityClass = (priority) => {
            const p = String(priority || '').toLowerCase();
            if (p.includes('quick')) return 'badge-priority-quick';
            if (p.includes('second')) return 'badge-priority-second';
            if (p.includes('watch') || p.includes('experiment')) return 'badge-priority-watch';
            if (p.includes('defer')) return 'badge-priority-defer';
            return 'badge-priority-other';
        };

        const norm = (s) => String(s || '').toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
        const canonCat = (s) => {
            const x = norm(s);
            if (!x) return '';
            if ((x.includes('ccai') || x.includes('contact center') || x.includes('voicebot')) && x.includes('inbound')) return 'ccai-inbound';
            if ((x.includes('ccai') || x.includes('contact center') || x.includes('voicebot')) && x.includes('outbound')) return 'ccai-outbound';
            if (x.includes('chatbot')) return 'chatbot';
            if (x.includes('kms') && (x.includes('standalone') || x.includes('stand alone'))) return 'kms ai (stand alone)';
            if (x.includes('kms') && (x.includes('embedded') || x.includes('omnix') || x.includes('omni'))) return 'kms ai (embedded on omnix)';
            if (x.includes('kip') || x.includes('komplain')) return 'auto kip';
            if (x.includes('proctoring')) return 'proctoring ai';
            if (x.includes('document') && (x.includes('extraction') || x.includes('extract') || x.includes('ocr'))) return 'extraction';
            if (x.includes('document') && (x.includes('summarization') || x.includes('summary') || x.includes('ringkas'))) return 'summarization';
            if (x.includes('document') && (x.includes('verification') || x.includes('verifikasi'))) return 'verification';
            if (x.includes('document') && (x.includes('matching') || x.includes('match'))) return 'matching';
            if (x.includes('document') && (x.includes('classification') || x.includes('klasifikasi'))) return 'classification';
            if (x.includes('rpa') || x.includes('robotic process')) return 'rpa';
            return x;
        };

        const detectCategoriesFromText = (text) => {
            const s = norm(text);
            const has = (kw) => s.includes(norm(kw));
            const cats = [];
            if (has('contact center')) {
                if (has('voicebot') && has('inbound')) cats.push('ccai-inbound');
                if (has('voicebot') && has('outbound')) cats.push('ccai-outbound');
                if (has('chatbot')) cats.push('chatbot');
                if ((has('kms') || has('kms ai')) && (has('stand alone') || has('standalone'))) cats.push('kms ai (stand alone)');
                if ((has('kms') || has('kms ai')) && (has('embedded') || has('omni') || has('omnix'))) cats.push('kms ai (embedded on omnix)');
                if (has('auto kip') || has('kip') || has('komplain')) cats.push('auto kip');
            }
            if (has('document ai') || has('documentai') || has('doc ai') || has('document')) {
                if (has('extraction') || has('extract') || has('ekstrak') || has('ocr')) cats.push('extraction');
                if (has('summarization') || has('summary') || has('ringkas')) cats.push('summarization');
                if (has('verification') || has('verifikasi')) cats.push('verification');
                if (has('matching') || has('match')) cats.push('matching');
                if (has('classification') || has('klasifikasi')) cats.push('classification');
            }
            if (has('rpa') || has('robotic process')) cats.push('rpa');
            if (has('proctoring') || has('proctoring ai')) cats.push('proctoring ai');
            return Array.from(new Set(cats.map(canonCat).filter(Boolean)));
        };

        const detectCategoriesFromConversation = (conv) => {
            const out = [];
            for (let i = conv.length - 1; i >= 0; i--) {
                const m = conv[i];
                const found = detectCategoriesFromText(String(m?.text || ''));
                for (const k of found) out.push(k);
                if (out.length) break;
            }
            return Array.from(new Set(out));
        };

        const getAvailableCategories = () => {
            const set = new Map();
            for (const q of questionsList) {
                const orig = String(q.category || '').trim();
                const canon = canonCat(orig);
                if (!canon) continue;
                if (!set.has(canon)) set.set(canon, orig);
            }
            return Array.from(set.values());
        };

        const addAssessmentToChart = (a) => {
            if (!mappingChart) return;
            const x = Number.isFinite(a?.feasibility) ? a.feasibility : 0;
            const y = Number.isFinite(a?.impact) ? a.impact : 0;
            const invalid = !(Number.isFinite(a?.feasibility) && Number.isFinite(a?.impact));
            mappingChart.data.datasets[0].data.push({
                x,
                y,
                label: a.use_case_name,
                priority: a.priority,
                invalid
            });
            mappingChart.update();
        };

        

        const parseNumber = (s) => {
            if (s == null) return null;
            const clean = String(s).replace(',', '.');
            const n = parseFloat(clean);
            return Number.isFinite(n) ? n : null;
        };

        const parseAssessmentFromText = (text) => {
            const t = String(text || '');
            const find = (re) => {
                const m = t.match(re);
                return m ? m[1].trim() : null;
            };

            const useCase = find(/Use\s*case:\s*(.+)/i);
            const domain = find(/Domain:\s*(.+)/i);
            const impactStr = find(/Impact[^:]*:\s*([0-9]+(?:[\.,][0-9]+)?)/i);
            const feasStr = find(/Feasibility[^:]*:\s*([0-9]+(?:[\.,][0-9]+)?)/i);
            const totalStr = find(/Total[^:]*:\s*([0-9]+(?:[\.,][0-9]+)?)/i);
            const priority = find(/Priority\s*class:\s*([^\n]+)/i);

            const impact = parseNumber(impactStr);
            const feasibility = parseNumber(feasStr);
            const total = parseNumber(totalStr);

            if (useCase && domain && impact != null && feasibility != null && total != null && priority) {
                return {
                    use_case_name: useCase,
                    domain,
                    impact,
                    feasibility,
                    total,
                    priority,
                    timestamp: new Date().toISOString()
                };
            }
            return null;
        };

        const addMessage = (role, text) => {
            const row = document.createElement('div');
            row.className = `msg msg-${role}`;
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            bubble.textContent = text;
            row.appendChild(bubble);
            chatMessages.appendChild(row);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        };

        const send = async () => {
            const text = chatInput.value.trim();
            if (!text) return;
            chatInput.value = '';
            addMessage('user', text);
            conversation.push({ role: 'user', text });

            loading.style.display = 'flex';
            sendButton.disabled = true;

            try {
                let flow = /\b\/qna\b/i.test(text) ? 'qna' : (/\b\/devguide\b/i.test(text) ? 'devguide' : '');
                if (/\b\/qna\b/i.test(text)) {
                    qnaActive = true;
                    qnaStep = 1;
                    const catsStart = detectCategoriesFromText(text);
                    const catsConv = detectCategoriesFromConversation(conversation);
                    qnaCategory = catsStart[0] || catsConv[0] || qnaCategory || '';
                } else if (qnaActive) {
                    const lastAssistant = [...conversation].reverse().find(m => m.role === 'assistant');
                    const s = String(lastAssistant?.text || '');
                    const mr = s.match(/Q\s*(\d+)\s*\/\s*(\d+)/i);
                    if (mr) {
                        const k = parseInt(mr[1], 10);
                        const n = parseInt(mr[2], 10) || 20;
                        qnaStep = Math.min(k + 1, n);
                        if (qnaStep >= n + 1) qnaActive = false;
                    }
                    if (!qnaCategory) {
                        const catsConv = detectCategoriesFromConversation(conversation);
                        qnaCategory = catsConv[0] || '';
                    }
                }
                if (qnaActive) flow = 'qna';
                const assessmentComplete = !!lastAssessment;
                const modules = qnaActive ? { qna: { step: qnaStep, category: qnaCategory } } : undefined;
                const response = await fetchWithTimeout('/.netlify/functions/score', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ messages: conversation, flow, assessmentComplete, modules })
                }, 60000);

                if (!response.ok) {
                    const dataText = await response.text();
                    let msg;
                    let statusCode = response.status;
                    try {
                        const errorData = JSON.parse(dataText);
                        const base = errorData.error || errorData.message || dataText;
                        const extras = [];
                        if (errorData.status) statusCode = Number(errorData.status) || statusCode;
                        if (errorData.details) extras.push(`details: ${errorData.details}`);
                        extras.push(`status: ${statusCode}`);
                        if (Array.isArray(errorData.availableModels)) {
                            const modelsPreview = errorData.availableModels.slice(0, 10).join(', ');
                            extras.push(`models: ${modelsPreview}`);
                        }
                        if ([503, 504, 429].includes(Number(statusCode))) {
                            extras.push('Saran: tunggu sebentar lalu coba lagi; ringkas narasi; gunakan model cepat.');
                        }
                        msg = [base, ...extras].join('\n');
                    } catch {
                        msg = dataText || `HTTP error! status: ${statusCode}`;
                    }
                    throw new Error(msg);
                }

                const data = await response.json();
                const reply = data.message || '(kosong)';
                conversation.push({ role: 'assistant', text: reply });
                addMessage('assistant', reply);

                // Coba parsing hasil /score menjadi objek terstruktur untuk grafik & simpan
                const parsed = parseAssessmentFromText(reply);
                if (parsed) {
                    parsed.rawText = reply;
                    lastAssessment = parsed;
                    saveButton.disabled = false;
                    saveStatus.textContent = 'Siap disimpan ke Google Sheets.';
                } else {
                    saveButton.disabled = true;
                    saveStatus.textContent = '';
                }

            } catch (error) {
                console.error('Error fetching score:', error);
                addMessage('assistant', `${error.message}`);
            } finally {
                loading.style.display = 'none';
                sendButton.disabled = false;
            }
        };

        sendButton.addEventListener('click', send);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                send();
            }
        });

        saveButton.addEventListener('click', async () => {
            if (!lastAssessment) return;
            saveButton.disabled = true;
            saveStatus.textContent = 'Menyimpan…';
            try {
                const resp = await fetchWithTimeout('/.netlify/functions/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ assessment: lastAssessment })
                }, 60000);
                const json = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    const msg = json.error || json.message || 'Gagal menyimpan.';
                    throw new Error(msg);
                }
                saveStatus.textContent = 'Tersimpan ✔';
                loadSheetButton.click();
            } catch (err) {
                console.error('Save error:', err);
                const message = /timeout/i.test(String(err?.message || ''))
                    ? 'Gagal: proses simpan melebihi batas waktu.'
                    : `Gagal: ${err.message}`;
                saveStatus.textContent = message;
            } finally {
                saveButton.disabled = false;
            }
        });

        

        loadSheetButton.addEventListener('click', async () => {
            try {
                sheetItems.splice(0, sheetItems.length);
                if (mappingChart) {
                    mappingChart.data.datasets[0].data = [];
                    mappingChart.update();
                }
                const resp = await fetchWithTimeout('/.netlify/functions/list', { method: 'GET' }, 60000);
                const json = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    const parts = [];
                    if (json.error) parts.push(json.error);
                    if (json.details) parts.push(json.details);
                    const msg = parts.length ? parts.join(' — ') : 'Gagal memuat dari Sheets.';
                    throw new Error(msg);
                }
                const items = Array.isArray(json.items) ? json.items : [];
                for (const it of items) {
                    const a = {
                        timestamp: it.timestamp || '',
                        use_case_name: it.use_case_name || '',
                        domain: it.domain || '',
                        impact: parseNumber(it.impact),
                        feasibility: parseNumber(it.feasibility),
                        total: parseNumber(it.total),
                        priority: it.priority || '',
                        rawText: it.rawText || ''
                    };
                    const s0 = String(a.timestamp || '').trim().toLowerCase();
                    const s1 = String(a.use_case_name || '').trim().toLowerCase();
                    const s2 = String(a.domain || '').trim().toLowerCase();
                    const s6 = String(it.priority || '').trim().toLowerCase();
                    const s7raw = String(it.rawText || '').trim().toLowerCase();
                    const isHeader = (s0 === 'timestamp' && s1 === 'use_case_name' && s2 === 'domain' && s6 === 'priority' && s7raw === 'rawtext');
                    if (isHeader) continue;
                    sheetItems.push(a);
                    if (a.impact != null && a.feasibility != null && a.total != null) {
                        addAssessmentToChart(a);
                    }
                }
                saveStatus.textContent = items.length > 0 ? 'Data dimuat dari Sheets.' : '';
                if (sheetCount) sheetCount.textContent = `Dimuat dari Sheets: ${sheetItems.length} item`;
                const renderSheetList = (rows) => {
                    if (!sheetTable) return;
                    const tbody = sheetTable.querySelector('tbody');
                    if (!tbody) return;
                    tbody.innerHTML = '';
                    for (const x of rows) {
                        const invalid = !(Number.isFinite(x?.impact) && Number.isFinite(x?.feasibility) && Number.isFinite(x?.total));
                        const tr = document.createElement('tr');
                        if (invalid) tr.className = 'row-invalid';
                        const badgeClass = getPriorityClass(x.priority);
                        tr.innerHTML = `
                            <td>${x.timestamp || ''}</td>
                            <td>${x.use_case_name || ''}</td>
                            <td>${x.domain || ''}</td>
                            <td class="num">${x.impact ?? ''}</td>
                            <td class="num">${x.feasibility ?? ''}</td>
                            <td class="num">${x.total ?? ''}</td>
                            <td><span class="badge ${badgeClass}">${x.priority || ''}</span></td>
                        `;
                        tbody.appendChild(tr);
                    }
                };
                renderSheetList(sheetItems);
            } catch (err) {
                saveStatus.textContent = `Gagal: ${err.message}`;
            }
        });

        // Inisialisasi grafik saat halaman siap
        const loadQuestions = async () => {
            try {
                const resp = await fetchWithTimeout('/.netlify/functions/list?tab=pertanyaan', { method: 'GET' }, 60000);
                const json = await resp.json().catch(() => ({}));
                const items = Array.isArray(json.items) ? json.items : [];
                questionsList.splice(0, questionsList.length);
                for (const it of items) {
                    const s0 = String(it.question || '').trim();
                    const s1 = String(it.category || '').trim();
                    if (!s0) continue;
                    questionsList.push({ question: s0, category: s1 });
                }
                questionsLoaded = true;
            } catch (_) {}
        };
        initChart();
        loadQuestions();
        loadSheetButton.click();
    </script>
</body>
</html>